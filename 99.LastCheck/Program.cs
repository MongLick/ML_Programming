using System.Security.Cryptography.X509Certificates;

namespace _99.LastCheck
{
	internal class Program
	{
		/// <summary>
		/// 문서 주석은 이렇게 사용한다. Main에 마우스 커서를 올리면 이 글이 뜬다.
		/// </summary>
		static void Main(string[] args)
		{
			// 주석 소스 코드에 영향을 주지 않는 텍스트이다.
			// 소스 코드에 대한 의도를 설명하기 위한 용도로 사용한다.

			// 주석 종류는 3가지가 있다.
			// // 한 줄 주석 // 이후 텍스트를 주석으로 취급한다.
			// /* 여기부터 */ 여기까지 텍스트를 주석으로 취급한다.
			/// 문서 주석 함수 또는 클래스 앞에 /// 입력으로 자동완성 및 통합 개발 환경에서 정보표시기능이 있다.

			// using 지시문은 소스코드의 상단부에 우치하며 네임스페이스를 선언한다. 선언 이후 소스코드에서 네임 스페이스 안의 기능을 사용한다.

			// 네임스페이스는 기능이다 구분이 비슷한 기능들을 하나의 이름 아래 묶는 기능이다.
			// 수 많은 클래스 사용에 혼란이 적도록 용도/분야 별로 정리를 한 것이다.

			// 클래스는 c# 프로그램을 구성하는 기본 단위이며 데이터와 기능을 구성한다.
			// 메인 함수는 프로그램의 시작지점이 되는 함수이다.
			// c# 프로그램은 반드시 하나의 main 함수를 포함해야한다.

			// 프로그램은 main 함수를 시작으로 순서대로 처리된다.
			// 표준입출력
			// 콘솔은 컴퓨터와 사용자가 소통하기 위한 클래스이다.

			// bool 논리형, int 정수형, float 부동소수점 실수, double 부동소수점 실수, char 유니코드 문자형 키 한개, string 유니코드 문자열 한 줄 등이 있다.
			// 변수는 데이터를 저장하기 위해 프로그램에 의해 이름을 항당 받은 메모리 공간이다. 데이터를 저장할 수 있는 ㅔㅁ모리 공간을 의마혐, 저장된 값은 변경이 가능하다.
			// 변수 선언 및 초기화 자료형의 선언하고 빈칸 뒤에 변수이름을 작성하여 변수를 선언한다. 선언한 변수에 값을 처음 할당하는 과정을 초기화라고 한다. 변수 선언과 초기화 과정을 동시에 진행할 수 있다.

			Console.Write("출력 하기");
			Console.WriteLine("출력 하면서 한 줄 띄기");
			Console.WriteLine("ReadLine");
			Console.ReadLine();
			// ReadLine은 키의 입렵 값을 받는다. 길게 쓸 수 있고 엔터를 누르면 넘어감
			Console.WriteLine("ReadKey");
			Console.ReadKey();
			// ReadKey는 키의 입력을 받는다. 키를 한 개만 눌러도 바로 넘어간다.
			Console.WriteLine();

			int iValue = 10; // int 자료형의 이름이 iValue인 변수에 10의 데이터를 초기화한다.
			float fValue;  // float 자료형의 이름이 fValue인 변수를 선언하지만 값을 초기화하지 않았다.
						   // 같은 이름의 변수는 사용이 불가능하다.
						   // 선언한 변수에 값을 초기화하기 전까지는 사용이 불가능하다. iValue는 사용이 가능하지만 fValue는 사용이 불가능하다.

			// 변수에 데이터 저장 대입 연산자 좌측에 변수를 배치한다. 
			iValue = 5; // iValue 변수에 5의 데이터를 저장한다.
			fValue = 10.5f; // fValue 변수에 10.5f 데이터를 초기화한다.
							// 1.2와 1.2f는 다른 것 이다. 기본적으로 소수점 뒤에는 d가 붙어 있다
							// double이 float보다 크니 float에 10.5는 더블형 자료형이니 넣을 수 없는 것이라 뒤에 f를 붙여 10.5f로 만들어야 하는 것 이다.

			// 변수의 데이터 불러오기 데이터가 필요한 곳에 변수명을 배치한다.
			int rValue = 20;
			int iValue2 = rValue; // 이렇게 하면 iValue2에는 rValue의 값인 20이 들어가게 된다.
			Console.WriteLine(rValue);
			Console.WriteLine(iValue2);

			int level = 0; // 초기화
			level = 10; // 대입
			int level2; // 선언
			level2 = 10; // 초기화
			level2 = 20; // 대입
						 // 값을 지정을 안 하면 선언 값을 처음 넣었을 때가 초기화 값을 바꿨을 때가 대입이다.

			Console.WriteLine(level2);
			level2 = 50;
			Console.WriteLine(level2);
			level2 = 100;
			Console.WriteLine(level2);
			float level3 = 10.23456f;
			Console.WriteLine($"{level3:F3}");
			// f3은 소수점 3번 째 자리까지만 보여준다라고 표시한 것 이다.
			Console.WriteLine($"{level3,+10:F3}");
			// 앞에 10칸 띄우기
			Console.Write($"{level3,-10:F3}");
			// 뒤에 10칸 띄우기
			Console.WriteLine("잘 띄워졌나?");

			// 상수는 프로그램일 싱행되는 동안 변경할 수 없는 데이터이다.
			// 프로그램에서 값이 변경되기를 원하지 않는 데이터가 있을 경우에 사용한다.
			// 저장된 값은 프로그램 종료시까지 변경이 불가능하다.
			// 상수 선언 및 초기화 변수 선언 앞에 const 키워드를 추가하여 상수 선언을 한다.
			const int MAX = 200; // MAX 상수 변수를 선언하고 초기화한다.
			Console.WriteLine(MAX);
			// const int Min; 상수는 초기화 없이 사용이 불가능하다. 선언 당시 바로 초기화를 진행시켜야한다.
			// MAX = 500; 상수는 데이터 값을 변경할 수 없다.
			// 상수는 항상 선언과 초기화를 같이 해줘야한다.
			// 상수는 대문자로만 사용하는 것이 일반적이다.

			// 동일한 자료형의 요소들로 구성된 데이터 집합이다.
			// 인덱스를 통하여 배열송에 접근할 수 있다.
			// 배열의 처음 요소의 인덱스는 0부터 시작한다.

			// 1차원 배열 사용 자료형 뒤에 []괄호를 추가하여 배열로 사용함을 선언한다.
			int[] iArray; // int 배열 선언
			iArray = new int[20]; // int 데이터를 20개 가지는 배열을 생성한 것이다.
			iArray[0] = 20; // 배열의 0번째 변수에 20이라는 데이터를 대입한 것이다.
			float[] fArray = { 1.1f, 2.2f, 3.3f, 4.4f }; // 배열 선언과 초기화 배열의 크기는 초기화한 값만큼 자동으로 설정된다. 이렇게 하면 크기 4개의 배열이다.

			// 다차원 배열은 추가하는 차원 수 만큼','를 추가해주면 된다.
			int[,] matrix = new int[5, 10]; // 이러면 데이터 50개를 가지는 배열을 생성한 것이다.
			int[,,] cube = new int[3, 5, 10]; // 10개짜리 5개 3 그룹이니 150개이다.

			matrix[1, 3] = 10; // 을 하면 가로 3번 째 세로 1번째 배열에 10이라는 데이터가 들어가게된다.

			// 형변환은 데이터를 선언한 자료형에 맞는 형태로 변환하는 작업이다. 다른 자료형의 데이터를 저장하기 위해선 형변환 과정을 거쳐야하며, 이 과정에서 보관할 수 없는 데이터는 버려진다.
			// 명시적 형변환 - 수동은 형변활 데이;터의 앞에 변환할 자료형을 괄호안에 넣어 형변환을 진행해준다.
			int damage = (int)29.9f;//29.9를 int로 변환하는 과정 중 보관할 수 없는 소수점은 버려진다. 그래서 29로 나온다.
			int intValue = (int)1.2; // 1.2를 int로 변환하는 과정중 보관할 수 없는 소수점은 버려진다. // int intValue = 1.2; // 명시적 형변환 없이 변환은 불가능하다.
			Console.WriteLine(intValue);
			// 묵시적 형변환 - 자동
			// int < float < double순이다.
			// 데이터에 손실이 없으면 자동으로 변환이 된다.
			double d1 = 1;
			float d2 = 1;
			double d3 = 123.456f; // double이 float를 포함하는 더 큰 범위이니 자동형변환이 가능하다.

			// 문자 형변환과 아스키코드 유니코드
			// 아스키코드는 이진법을 사용하는 컴퓨터에서 문자를 표현하기 위해 정해둔 문자와 숫자의 매칭표이다.
			// 유니코드는 영어만 표현이 가능했던 아스키코드에서 전세계의 모든 문자를 다루도록 설계한 매칭표이다.
			char key = (char)65; // key에는 65가 해당되는 A가 들어가게 된다.
			int value = (int)'a'; // value에는 a에 해당하는 97이 들어가게된다.
			Console.WriteLine(key);
			Console.WriteLine(value);

			// int hp = int("100"); 문자열 형식은 숫자로 변형할 수 없다. char는 되는데 string은 불가능하다. 감자라면 감자가 숫자로 몇인지 정해져있지 않기 때문
			int hp = int.Parse("100");
			float p = float.Parse("0.5");
			Console.WriteLine(hp);
			Console.WriteLine(p);
			// int b = int.Parse("감자");
			// 문자가 들어간 순간 숫자로 변형 될 수 없다. 그래서 0.2는 가능하지만 0.2f는 불가능하다.

			int.TryParse("100", out hp); // 바꿀 수 있으면 100으로 해주고 바꿀 수 없다면 0으로 변환이 된다.
			string hundred = 100.ToString(); // 숫자를 문자형으로 바꿀라면 뒤에 .ToStirng을 해주면 된다.
			// 결론 : 숫자를 문자로는 무조건 바꿀 수 있다. ""만 붙여주면 되기 때문이다 모든 문자를 숫자로 바꿀수는 없다. 숫자인 문자만 변경이 가능하다. 100 가능 100f는 불가능하다.
		}
	}
}
