using static System.Net.Mime.MediaTypeNames;
using System.Reflection;
using System;

namespace _08.Memory_Class_Task
{
	internal class Program
	{
		static void Main(string[] args)
		{
			// 기본 접근 제어 클래스와 구조체는 둘 다 private이다.
			// 상속 가능 여부 클래는 가능하고 구조체는 불가능하다.

			// 클래스는 참조형식(Reference) ,구조체는 값형식(Value) 

			// 값형식은 스택 공간에 데이터를 할당한다.
			// 스택은 정적으로 메모리에 할당된다. 해당 영역에 있는 변수들은 함수를 빠져나가면 소멸된다.
			// FILO(First In Last Out), LIFO(Last In First Out)구조로
			// 처음 생성된 변수가 제일 마지막에 소멸되고 제일 마지막에 만든 변수가 제일 먼저 소멸된다.

			// 참조형식은 힙 공간에 데이터를 할당한다.
			// 힙은 동적으로 메모리에 할당된다. 가비지 컬렉터가 해당 메모리가 사용되지 않는다고 판단이 되면 마크를 해놓고 한 번에 데이터를 소멸시킨다.
			// 스택에 변수(주소지를 가지고 있음)가 들어가고, 힙 영역에 new(인스턴스 : 실제 값을 가지고 있음)가 들어간다.

			// Call By Value는 인자로 받은 값을 복사하여 처리한다. 이 경우에 기존 값을 보존할 수 있는 대신 복사본 만큼의 메모리의 사용량이 증가한다.
			// Call By Reference는 인자로 받은 값의 주소를 참조하여 처리한다. 때문에 메소드내에서 직접 값의 영향을 줄 수 있다. 이 경우에는 기존 값을 보존할 수 없지만, 복사본을 생성하지 않아 비교적 속도가 빠르다.

			// 데이터 영역은 정적 변수가 해당 영역에 속하고 프로그램이 종료될 때까지 지워지지 않고 컴파일 시점에 크기가 할당된다.
			// 힙 영역은 사용자 관리 영역으로, 사용자 정의에 의해 할당된 메모리에 저장하거나 해제하는 동적 할당을 사용한다. 객체의 참조값이 해당 영역에 속한다.
			// 코드 블럭이 종료될 때 스택에 할당된 데이터를 가리키는 주소는 사라지지만, 힙 영역에 존재하는 데이터 값은 남아있게 된다. C#은 가비지 컬렉터가 해당 데이터를 적절한 시점에 소거한다.
			// 스택 영역은 지역 변수와 매개 변수가 해당 영역에 속하고 컴파일 시점에 크기를 할당하는 정적 할당을 사용된다. 코드 블럭이 종료될 때 FILO 구조로 소멸된다.
			// 함수에 int a 했던 것이 지역 변수이다.

			// 스택 영역과 힙 영역은 같은 공간을 공유한다고 볼 수 있다.
			// 스택 영역과 힙 영역은 사용량에 따라 늘어나고 줄어든다..
			// 각각의 영역이 과도하게 사용되면 스택 영역은 스택 영역을 초과하는 스택 오버플로우, 힙 영역은 데이터 할당 무시 등의 오류가 발생할 수 있다.	

			// 과도한 재귀 또는 너무 큰 지역 변수를 선언하게 되어 stack 영역의 크기를 초과해 다른 메모리 영역(Heap 영역)을 침범하는 현상을 말한다. 프로그램이 다운된다.
			// 힙 영역은 스택 영역과 마찬가지로 영역이 가변한다.
			// 둘의 차이점으로 스택 영역은 사용량이 너무 많아지면 힙 영역을 침범하는 Stack Overflow가 발생할 수 있지만, 힙 영역은 스택 영역이 할당되고 남은 공간을 사용하기 때문에 사용할 수 있는 공간만큼만 늘어나고 초과한 데이터는 할당되지 않는다.
			// 따라서 Heap Overflow는 발생하지 않지만, 데이터가 할당되지않는 오류가 발생할 수 있다.

			// C#은 Managed Heap을 사용한다.. managed heap은 스택과 유사하게 포인터에 값을 더하는 식으로 데이터를 할당하고, 메모리 관리의 효율성을 위해 “세대”라는 개념을 도입해 공간을 3개(0~2세대)로 나눈다.
			// 세대는 몇번의 가비지 컬렉션을 거쳤는지를 나타낸다. 힙 메모리에 새로 할당되는 object는 0세대에 저장하고 0세대가 꽉찬 경우 가비지 컬렉션을 수행한다. 이 후 남아있는 object들의 세대를 1세대에 저장한다.
			// 이러한 방식으로 2세대까지 꽉 찬다면 모든 세대에 대해 가비지 컬렉션을 진행한다. 이를 Full GC라고 부르며, 일정 시간 프로그램을 멈추고 가비지 컬렉션을 수행하기에 가비지를 잘 관리해 해당 상황을 최대한 피해야한다.

			// 표시단계:Marking-재배치단계:Relocating-압축단계:Compacting 을 수행하며 가비지 컬렉션을 수행한다.
			// 가비지 컬렉션 주기가 시작될 때 모든 오브젝트를 가비지로 가정한다. 이 상태에서 가비지 컬렉터는 루트 목록을 돌며 각 루트가 참조하는 것들을 마킹한다.
			// (힙 object가 다른 힙 object를 참조한다면 그 또한 마킹함.)
			// 즉, 루트 목록에서 시작되는 연결리스트를 만든다. 이를 표시단계:Marking이라고 한다.
			// 여기서 가비지 컬렉터는 루트 목록에서 도달할 수 없는 object들을 가비지로 간주한다. 가비지가 차지한 공간은 비어 있는 공간으로 간주한다. 이를 재배치단계:Relocating(Sweep)라고 한다.
			// 탐색이 종료되면 비어있는 공간에 인접한 도달할 수 있는 object들을 메모리 복사를 통해 덮어 씌운다. object의 이동이 끝나면 가비지 컬렉터의 포인터 위치(managed heap pointer, application root) 또한 적절하게 수정한다.
			// 이를 압축단계:Compacting라고 한다.
			// 최종적으로 다음과 같은 깨끗한 상태의 메모리를 얻게되고 이것이 가비지 컬렉션의 한 주기에 대한 과정/ 결과이다.

			// 필요 이상의 객체를 만들지 않는다.
			// 너무 큰 객체를 할당하지 않는다. (대형 개체 힙은 메모리 복사를 통해 object를 압축하는 과정의 비용이 크기 때문에 해제된 공간을 그대로 둔다.또, CLR에서는 대형 개체 힙을 아예 2세대 힙으로 간주하기 때문에 가비지 컬렉션을 하려면 Full GC가 불가피하게 일어난다.)
			// 복잡한 참조 관계를 만들지 않는다. (가비지 컬렉션 후 도달할 수 있는 object의 세대를 sweep하는 과정에서 복잡한 참조 관계의 메모리들의 주소를 모두 수정하는 과정을 거쳐야한다.)
		}
	}
}
